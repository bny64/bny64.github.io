<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>bny-blog</title>
    <link>https://bny64.github.io/</link>
    
    <atom:link href="https://bny64.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 13 Dec 2020 01:19:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Http通信とSocket通信の違い</title>
      <link>https://bny64.github.io/2020/12/13/http-socket-jp/</link>
      <guid>https://bny64.github.io/2020/12/13/http-socket-jp/</guid>
      <pubDate>Sun, 13 Dec 2020 01:19:14 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;一般的に、デバイスで必要とされるデータはサーバーで管理します。 ネットワークを通じてサーバからデータを取得するための通信方式には、大きく分けてHttp通信とSocket通信の2種類がありますが、今日はこの2つの通信方式の違いについて見ていきたいと思います。&lt;/p&gt;
&lt;h4 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>一般的に、デバイスで必要とされるデータはサーバーで管理します。 ネットワークを通じてサーバからデータを取得するための通信方式には、大きく分けてHttp通信とSocket通信の2種類がありますが、今日はこの2つの通信方式の違いについて見ていきたいと思います。</p><h4 id="Http-通信"><a href="#Http-通信" class="headerlink" title="Http 通信"></a>Http 通信</h4><p><strong>クライアントのリクエストがある場合のみ、サーバーが応答(Response)して当該情報を送信し、すぐに接続を終了する方式</strong></p><p>Http通信はClientの要請があるときだけServerが応答して処理をした後に連結を絶つ方法です。 このような接続方法は<code>Clientが要請を送る場合にのみServerが応答するワン・ウェイ・コニュニケーション</code>で、ServerがClientで要請を送ることはできません。 理解を助けるために皆さんがこのブログの内容を見るためにブログに入ってくる状況を例に挙げてみます。 皆さんがこのブログのためのリンクをクリックした瞬間にClient(ウェブ)はServer(ウェブサーバ)にこの文に対する内容を送ってほしいと要請をしたのです。 この文に対する内容を受けた後は、連結が終了されます。 そのために要請を送るとき、内容を待つ時間と共に連結する時間が入るようになります。 このようなHttp通信は、リアルタイム接続がなく、<code>必要な場合のみServerにアクセスするコンテンツ中心のデータを使用するとき用意</code>です。 もしブログに対する内容を要請するため、リアルタイムでつなぐを維持するSocket通信を使用することになると、ブログの内容を受けた後も、引き続き通信のための連結が成立しており、負荷がかかります。 一般的にモバイルアプリケーションは必要な場合のみServerで情報を要請する場合が多いが、このようなWeb ServerでHttp通信を主に使用して費用や保守などほとんどの方面でいいです。</p><p><img src="http.png" alt="http 通信"></p><h6 id="Http-通信の特徴"><a href="#Http-通信の特徴" class="headerlink" title="Http 通信の特徴"></a>Http 通信の特徴</h6><ul><li> クライアントがリクエストを送信した場合にのみ、サーバーが応答するワン・ウェイ・コニュニケーションである。</li><li> サーバーからの応答を受けた後は、接続がすぐに終了する。 </li><li> リアルタイムの接続ではなく、必要な場合にのみサーバーに要請を送る状況に有用である。</li><li> 要請を送ってサーバーの応答を待つアプリケーション(Android or Ios)の開発に主に使われる。</li></ul><h4 id="Socket-通信"><a href="#Socket-通信" class="headerlink" title="Socket 通信"></a>Socket 通信</h4><p><strong>サーバーとクライアントが特定ポートを通じてリアルタイムでツーウエー・コミュニケーションする方式</strong></p><p>Socket通信はHttp通信とは違って、<code>ServerとClientが特定Portを通じて連結を成立しており、リアルタイムでツーウエー・コミュニケーションする方式です</code>。 Clientのみ必要な場合に要請を送るHttp通信とは違って、Socket通信はServerもClientで要請を送ることができ、ずっとつながりを維持する連結志向型通信であるため、<code>リアルタイムの通信が必要な場合によく使用</code>されます。 例えば、リアルタイムStreamingの中継やリアルタイムでチャットと一緒に即座に情報をやり取りする場合に使用します。 例えば、リアルタイム動画StreamingサービスをHttp通信で具現したと仮定します。 このような場合に使用者がサーバに動画を要請するためには動画が終了される瞬間まで継続してHttp通信を送らなければならない、このような構造は引き続き連結を要請するために負荷がかかります。 従って、このような場合にはSocketを通じて具現することが適しています。</p><p><img src="socket.png" alt="socket 通信"></p><h6 id="Socket-通信の特徴"><a href="#Socket-通信の特徴" class="headerlink" title="Socket 通信の特徴"></a>Socket 通信の特徴</h6><p>-ServerとClientがずっとつながりを維持するツーウエー・コミュニケーションである。<br>-ServerとClientがリアルタイムでデータをやり取りする状況が必要な場合に使用される。<br>-リアルタイム動画Streamingやオンラインゲームなどのような場合によく使用される。</p><blockquote><footer><strong>参考</strong><cite><a href="https://mangkyu.tistory.com/48">mangkyu.tistory.com/48</a></cite></footer></blockquote>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/JAPANESE/">JAPANESE</category>
      
      <category domain="https://bny64.github.io/categories/JAPANESE/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/JAPANESE/STUDY/TECHNICAL-TERMS/">TECHNICAL TERMS</category>
      
      
      <category domain="https://bny64.github.io/tags/http-%E9%80%9A%E4%BF%A1/">http 通信</category>
      
      <category domain="https://bny64.github.io/tags/socket-%E9%80%9A%E4%BF%A1/">socket 通信</category>
      
      <category domain="https://bny64.github.io/tags/http-%E9%80%9A%E4%BF%A1-socket-%E9%80%9A%E4%BF%A1%E3%81%AE%E9%81%95%E3%81%84/">http 通信 socket 通信の違い</category>
      
      
      <comments>https://bny64.github.io/2020/12/13/http-socket-jp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Http communication and Socket communication difference</title>
      <link>https://bny64.github.io/2020/12/12/http-socket-en/</link>
      <guid>https://bny64.github.io/2020/12/12/http-socket-en/</guid>
      <pubDate>Sat, 12 Dec 2020 00:44:25 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Typically, the data that your device needs is managed by the server. There are two main communication methods for importing data from ser</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Typically, the data that your device needs is managed by the server. There are two main communication methods for importing data from servers over the network: Http communication and Socket communication, and today we’re going to look at the differences between these two methods. </p><h4 id="Http-communication"><a href="#Http-communication" class="headerlink" title="Http communication"></a>Http communication</h4><p><strong>How the server responds only to requests from clients, sends that information, and immediately terminates the connection</strong></p><p>Http communication is a method in which the server responds only to requests from the Client, processes them, and then disconnects. This connection is <code>one-way communication</code> in which the server responds only when the client sends the request, and the server cannot send the request to the client. To help you understand, let’s take an example of a situation in which you’re coming into a blog to see this article. As soon as you clicked on the link for this article, the Client asked you to send it to the server. The connection is terminated immediately after receiving the contents of this article. Therefore, when you send a request, it takes time to wait for the content and connect with it. These Http communications are not real-time connections, but <code>easy to use content-oriented data that accesses the server only when necessary</code>. If Socket communication is used to maintain a real-time connection to request the contents of the post, the connection is still established for communication even after receiving the post, which is under load. In general, mobile applications often request information to the server only when necessary, and these Web servers primarily use Http communications and are good for most aspects, including cost and maintenance.</p><p><img src="http.png" alt="http communication"></p><h6 id="Characteristics-of-Http-Communication"><a href="#Characteristics-of-Http-Communication" class="headerlink" title="Characteristics of Http Communication"></a>Characteristics of Http Communication</h6><ul><li>One-way communication in which the server responds only when the client sends a request.</li><li>After receiving a response from the server, the connection is terminated immediately.</li><li>Not a real-time connection, but useful for situations where requests are sent to the server only when necessary.</li><li>Mainly used in the development of applications (Android or Ios) that send requests and wait for responses from the server.</li></ul><h4 id="Socket-Communication"><a href="#Socket-Communication" class="headerlink" title="Socket Communication"></a>Socket Communication</h4><p><strong>How the Server and Client communicate in real time through a specific Port</strong></p><p>Unlike Http communication, Socket communication is <code>a way for two-way communication in real time as the server and the client form a connection through a specific port</code>. Unlike Http communication, which sends requests only when the client is required, Socket communication is <code>used frequently when real-time communication is required</code> because the server can also send requests to the client and is a connection oriented communication that maintains a continuous connection. For example, if you want to send and receive information immediately, such as live streaming or real-time chatting. For instance, suppose you have implemented a real-time video streaming service as Http communication. In such a case, users must continue to send Http communications until the moment the video is terminated, and this structure will be under load because it will continue to request connectivity. Therefore, it is appropriate to implement it through Socket in this case.</p><p><img src="socket.png" alt="socket Communication"></p><h6 id="Characteristics-of-Socket-Communication"><a href="#Characteristics-of-Socket-Communication" class="headerlink" title="Characteristics of Socket Communication"></a>Characteristics of Socket Communication</h6><ul><li>It is a two-way communication that keeps the server and the client connected.</li><li>Used when the server and the Client need to send and receive data in real time.</li><li>Often used in cases such as real-time video streaming or online games.</li></ul><blockquote><footer><strong>출처</strong><cite><a href="https://mangkyu.tistory.com/48">mangkyu.tistory.com/48</a></cite></footer></blockquote>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/ENGLISH/">ENGLISH</category>
      
      <category domain="https://bny64.github.io/categories/ENGLISH/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/ENGLISH/STUDY/TECHNICAL-TERMS/">TECHNICAL TERMS</category>
      
      
      <category domain="https://bny64.github.io/tags/http-communication/">http communication</category>
      
      <category domain="https://bny64.github.io/tags/socket-communication/">socket communication</category>
      
      <category domain="https://bny64.github.io/tags/http-communication-and-Socket-communication-difference/">http communication and Socket communication difference</category>
      
      
      <comments>https://bny64.github.io/2020/12/12/http-socket-en/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>(통신 방식) Http 통신과 Socket 통신 차이</title>
      <link>https://bny64.github.io/2020/12/11/http-socket/</link>
      <guid>https://bny64.github.io/2020/12/11/http-socket/</guid>
      <pubDate>Fri, 11 Dec 2020 00:54:01 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;일반적으로 단말기에서 필요로 하는 데이터들은 Server에서 관리합니다. 네트워크를 통해 서버로부터 데이터를 가져오기 위한 통신 방식은 크게 Http 통신과 Socket 통신 2가지가 있는데, 오늘은 이 2가지 통신 방식의 차이에 대해 알아보도록</description>
        
      
      
      
      <content:encoded><![CDATA[<p>일반적으로 단말기에서 필요로 하는 데이터들은 Server에서 관리합니다. 네트워크를 통해 서버로부터 데이터를 가져오기 위한 통신 방식은 크게 Http 통신과 Socket 통신 2가지가 있는데, 오늘은 이 2가지 통신 방식의 차이에 대해 알아보도록 하겠습니다. </p><h4 id="Http-통신"><a href="#Http-통신" class="headerlink" title="Http 통신"></a>Http 통신</h4><p><strong>Client의 요청(Request)이 있을 때만 서버가 응답(Response)하여 해당 정보를 전송하고 곧바로 연결을 종료하는 방식</strong></p><p>Http통신은 Client의 요청이 있을 때만 Server가 응답하여 처리를 한 후에 연결을 끊는 방식입니다. 이러한 연결 방식은 <code>Client가 요청을 보내는 경우에만 Server가 응답하는 단방향적 통신</code>으로, Server가 Client로 요청을 보낼수는 없습니다. 이해를 돕기 위해 여러분들이 이 글을 보기 위해 블로그에 들어오는 상황을 예로 들어보겠습니다. 여러분들이 이 글을 위한 링크를 클릭한 순간에 Client(웹)는 Server(웹서버)로 이 글에 대한 내용을 보내달라고 요청을 한 것입니다. 이 글에 대한 내용들을 받은 후에는 바로 연결이 종료됩니다. 그렇기 때문에 요청을 보낼때, 내용을 기다리는 시간과 함께 연결하는 시간이 들어가게 됩니다. 이러한 Http 통신은 실시간 연결이 아닌, <code>필요한 경우에만 Server로 접근하는 콘텐츠 위주의 데이터를 사용할 때 용이</code>합니다. 만약 게시물에 대한 내용을 요청하기 위해 실시간으로 연결을 유지하는 Socket통신을 사용하게 되면, 게시물을 받은 후에도 계속 통신을 위한 연결이 성립되어 있어 부하가 걸리게 됩니다. 일반적으로 모바일 어플리케이션은 필요한 경우에만 Server로 정보를 요청하는 경우가 많은데, 이러한 Web Server로 Http 통신을 주로 사용하며 비용 및 유지보수 등 대부분의 방면에서 좋습니다.</p><p><img src="http.png" alt="http 통신"></p><h6 id="Http-통신의-특징"><a href="#Http-통신의-특징" class="headerlink" title="Http 통신의 특징"></a>Http 통신의 특징</h6><ul><li>Client가 요청을 보내는 경우에만 Server가 응답하는 단방향 통신이다.</li><li>Server로부터 응답을 받은 후에는 연결이 바로 종료된다. </li><li>실시간 연결이 아니고, 필요한 경우에만 Server로 요청을 보내는 상황에 유용하다.</li><li>요청을 보내 Server의 응답을 기다리는 어플리케이션(Android or Ios)의 개발에 주로 사용된다.</li></ul><h4 id="Socket-통신"><a href="#Socket-통신" class="headerlink" title="Socket 통신"></a>Socket 통신</h4><p><strong>Server와 Client가 특정 Port를 통해 실시간으로 양방향 통신을 하는 방식</strong></p><p>Socket통신은 Http 통신과 달리 <code>Server와 Client가 특정 Port를 통해 연결을 성립하고 있어 실시간으로 양방향 통신을 하는 방식</code>입니다. Client만 필요한 경우에 요청을 보내는 Http 통신과 달리 Socket 통신은 Server 역시 Client로 요청을 보낼 수 있으며, 계속 연결을 유지하는 연결지향형 통신이기 때문에 <code>실시간 통신이 필요한 경우에 자주 사용</code>됩니다. 예를 들면, 실시간 Streaming 중계나 실시간 채팅과 같이 즉각적으로 정보를 주고받는 경우에 사용합니다. 예를 들어 실시간 동영상 Streaming 서비스를 Http 통신으로 구현하였다고 가정하겠습니다. 이러한 경우에 사용자가 서버로 동영상을 요청하기 위해서는 동영상이 종료되는 순간까지 계속해서 Http 통신을 보내야 하고 이러한 구조는 계속 연결을 요청하기 때문에 부하가 걸리게 됩니다. 그러므로 이러한 경우에는 Socket을 통해 구현하는 것이 적합합니다.</p><p><img src="socket.png" alt="socket 통신"></p><h6 id="Socket-통신의-특징"><a href="#Socket-통신의-특징" class="headerlink" title="Socket 통신의 특징"></a>Socket 통신의 특징</h6><ul><li>Server와 Client가 계속 연결을 유지하는 양방향 통신이다.</li><li>Server와 Client가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 사용된다.</li><li>실시간 동영상 Streaming이나 온라인 게임 등과 같은 경우에 자주 사용된다.</li></ul><blockquote><footer><strong>출처</strong><cite><a href="https://mangkyu.tistory.com/48">mangkyu.tistory.com/48</a></cite></footer></blockquote>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/KOREAN/">KOREAN</category>
      
      <category domain="https://bny64.github.io/categories/KOREAN/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/KOREAN/STUDY/TECHNICAL-TERMS/">TECHNICAL TERMS</category>
      
      
      <category domain="https://bny64.github.io/tags/http-%ED%86%B5%EC%8B%A0/">http 통신</category>
      
      <category domain="https://bny64.github.io/tags/socket-%ED%86%B5%EC%8B%A0/">socket 통신</category>
      
      <category domain="https://bny64.github.io/tags/http-%ED%86%B5%EC%8B%A0%EA%B3%BC-socket-%ED%86%B5%EC%8B%A0%EC%9D%98-%EC%B0%A8%EC%9D%B4/">http 통신과 socket 통신의 차이</category>
      
      
      <comments>https://bny64.github.io/2020/12/11/http-socket/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>What is TCP/IP ?</title>
      <link>https://bny64.github.io/2020/12/09/tcp-ip-en/</link>
      <guid>https://bny64.github.io/2020/12/09/tcp-ip-en/</guid>
      <pubDate>Wed, 09 Dec 2020 00:08:32 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP / IP&quot;&gt;&lt;/a&gt;TCP / IP&lt;/h4&gt;&lt;p&gt;There are various protocols for Internet programs </description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP / IP"></a>TCP / IP</h4><p>There are various protocols for Internet programs to communicate with, such as HTTP, SFTP and FTP. The most common protocol used in Internet protocols, as you all know, is IP, and the important thing here is that <code>TCP/IP</code> is not a hierarchy, but a protocol.<br><code>TCP/IP</code> runs on top of <code>TCP/IP</code> structural hierarchy slightly different from OSI7 hierarchy.<br><img src="tcp-ip_1.png" alt="tcp/ip"><br>It looks a little different from the OSI7 hierarchy.<br>You can see that the number of tiers is different, OSI is seven, while the TCP/IP tier is all four.</p><h4 id="1-Network-Interface-Layer"><a href="#1-Network-Interface-Layer" class="headerlink" title="1. Network Interface Layer"></a>1. Network Interface Layer</h4><p>This tier is responsible for reliable data transmission between Node and Node.<br>The network interface hierarchy is responsible for the physical and data link tiers of the OSI7 hierarchy.<br>Therefore, MAC addresses are used in this hierarchy.<br>MAC addresses are used because the network interface hierarchy covers the data link hierarchy.<br><img src="lan-card.jpg" alt="LAN CARD"><br>The equipment above is a LAN card. The exact name is NIC and <code>Network Interface Card</code>.<br>Network communication is not possible without a LAN card. A device that operates in the network interface hierarchy.</p><p>LAN includes Ethernet, TokenRing, FDDI, X.25, FrameRelay, PPP, and so on.</p><h4 id="2-Internet-Layer"><a href="#2-Internet-Layer" class="headerlink" title="2. Internet Layer"></a>2. Internet Layer</h4><p>The network hierarchy of the OSI7 hierarchy. You will be responsible for routing between hosts, such as the OSI7 hierarchy.<br>The protocols that work in the Internet hierarchy are:</p><ul><li><p>IP (Internet Protocol) : Untrusted, unconjugated  Datagram Protocol </p></li><li><p>Address Resolution Protocol (ARP) : Address translation protocol. Protocol that converts IP addresses to MAC addresses</p></li><li><p>RARP (Reverse ARP) : a protocol that looks for an IP address by MAC address.</p></li><li><p>ICMP (Internet Control Message Protocol) : State Diagnostic Message Protocol, which is used by leading programs to ping</p></li><li><p>Internet Group Message Protocol (IGMP) : protocol for multicast</p></li></ul><h4 id="3-Transport-Layer"><a href="#3-Transport-Layer" class="headerlink" title="3. Transport Layer"></a>3. Transport Layer</h4><p>Same as the transmission hierarchy in OSI7 hierarchy. A hierarchy responsible for reliable data transmission between processes.<br>A logical address is required to be responsible for process-to-process forwarding, but the port number used by the process is used as its logical address.<br>The protocols that work in the transport hierarchy are:</p><ul><li><p>TCP (Transmission Control Protocol) : A reliable connection-oriented protocol that provides error recovery through error handling and retransmission of the packets. Therefore, there is a lot of information attached to the TCP header.</p></li><li><p>User Datagram Protocol (UDP) : Untrusted and unreliable protocol. Do not take action if you lose your packet or if there is an error. Therefore, UDP headers have a simple structure.</p></li></ul><h4 id="4-Application-Layer"><a href="#4-Application-Layer" class="headerlink" title="4 . Application Layer"></a>4 . Application Layer</h4><p>The tier closest to the user. It is responsible for everything from 5 to 7 OSI tiers.<br>Server and client applications operate in this hierarchy. Services such as browsers and telnet that we know work in this hierarchy and use the forwarding hierarchy address, or port number, to work in order to work in this hierarchy. For example, http is equivalent to using port 88.<br>The protocols that work in the application hierarchy are:</p><ul><li><p>HTTP (Hyper-Text Transfer Protocol) : TCP-based protocol using port number 80.</p></li><li><p>Telnet : Use TCP port number 23. Use this protocol to connect remote terminals</p></li><li><p>SSH (Secure Shell) : Services like Telnet are vulnerable to security. Because the password is unencrypted, it is displayed as is. SSH is a complement to this. Use port number 22. A protocol such as SFTP is also used primarily on port 22.</p></li><li><p>FTP (File Transfer Protocol) : A file transfer protocol. FTP is used to download and upload files. FTP works with TCP because reliability is important when uploading or downloading files. Two ports are used.</p></li></ul><p>TCP port 20 is used for data transfer and TCP port 21 is used for control.</p><ul><li><p>Simple Mail Transfer Protocol (SMTP) : Mail transfer protocol. It runs over TCP and the port uses number 25.</p></li><li><p>POP3 (Post Office Protocol Version 3) : The protocol for receiving mail. Programs such as Outlook work using a protocol called POP3. Use TCP port 110.</p></li><li><p>Domain Name System (DNS) : Provides host information for a domain name. It basically runs over UDP. Basically, if you fail, you can request it again, and it’s not that important information. However, it also runs over TCP if reliability is required. Long data can operate on a TCP basis at the same time.</p></li></ul><p>Use UDP, TCP port 53.</p><p>As you can see, some ports cannot be used if the port number is used by a specific protocol. These ports are called well-known ports.</p><blockquote><footer><strong>reference :</strong><cite><a href="https://reakwon.tistory.com/68">reakwon.tistory.com/68</a></cite></footer></blockquote>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/ENGLISH/">ENGLISH</category>
      
      <category domain="https://bny64.github.io/categories/ENGLISH/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/ENGLISH/STUDY/TECHNICAL-TERMS/">TECHNICAL TERMS</category>
      
      
      <category domain="https://bny64.github.io/tags/TCP/">TCP</category>
      
      <category domain="https://bny64.github.io/tags/IP/">IP</category>
      
      <category domain="https://bny64.github.io/tags/TCP-IP/">TCP/IP</category>
      
      <category domain="https://bny64.github.io/tags/TCP-Meaning/">TCP Meaning</category>
      
      <category domain="https://bny64.github.io/tags/IP-Concept/">IP Concept</category>
      
      <category domain="https://bny64.github.io/tags/IP-Meaning/">IP Meaning</category>
      
      
      <comments>https://bny64.github.io/2020/12/09/tcp-ip-en/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TCP/IPとは?</title>
      <link>https://bny64.github.io/2020/12/07/tcp-ip-jp/</link>
      <guid>https://bny64.github.io/2020/12/07/tcp-ip-jp/</guid>
      <pubDate>Mon, 07 Dec 2020 03:30:29 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h4&gt;&lt;p&gt;インターネットプログラムが通信をするにあたって、HTTP、SFTP、FTPなど様々なプロトコルがあります。 </description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>インターネットプログラムが通信をするにあたって、HTTP、SFTP、FTPなど様々なプロトコルがあります。 インターネットプロトコルで最も多く使用される代表的なプロトコルは、皆さんご存知の通りIPです。 ここで重要なことは<code>TCPIP</code>は階層ではなくプロトコルであることです。<br><code>TCPIP</code>はOSI7  階層とは少し異なる<code>TCPIP</code>の構造的な階層の上で動作します。<br><img src="tcp-ip_1.png" alt="tcpip"><br>OSI7階層とは少し異なる様子です。<br>階層の個数も違って OSI  は7  階層であるのに対し、TCPIP  階層は4階層全てであることが分かります。</p><h4 id="1-ネットワークインタフェース階層-Network-Interface-Layer"><a href="#1-ネットワークインタフェース階層-Network-Interface-Layer" class="headerlink" title="1. ネットワークインタフェース階層 (Network Interface Layer)"></a>1. ネットワークインタフェース階層 (Network Interface Layer)</h4><p>この階層は、Node-To-Node間の信頼性のあるデータ伝送を担う階層です。<br>OSI7階層の物理階層とデータリンク階層の役割を、同ネットワークインタフェース階層が担っています。<br>したがって、MACアドレスがこの階層で使用されます。<br>ネットワークインタフェース階層がデータリンク階層まで担当するので、MACアドレスが使用されます。<br><img src="lan-card.jpg" alt="LANカード"><br>上の装備はランカードです。 正確な名称はNICといい<code>Network Interface Card</code>です。<br>LANカードがないとネットワーク通信はできません。ネットワークインタフェース階層で動作するデバイスです。</p><p>LAN上ではEthernet、TokenRing、FDDIなどがあり、WAN上ではX.25、FrameRelay、PPPなどがあります。</p><h4 id="2-インターネット階層-Internet-Layer"><a href="#2-インターネット階層-Internet-Layer" class="headerlink" title="2. インターネット階層 (Internet Layer)"></a>2. インターネット階層 (Internet Layer)</h4><p>OSI7階層のネットワーク階層を担う階層です。 OSI7階層のようにホスト間のルーティングを担当することになります。<br>インターネット階層で動作するプロトコルは以下の通りです。</p><ul><li><p> IP(Internet  Protocol):非信頼性、非連結指向データグラムプロトコル </p></li><li><p> ARP(Address  Resolution  Protocol):アドレス変換プロトコルです。 IPアドレスをMACアドレスに変換するプロトコル</p></li><li><p> RARP(Reverse  ARP):逆にMACアドレスでIPアドレスを探すプロトコル</p></li><li><p> ICMP（Internet  Control  Message  Protocol）:状態診断メッセージプロトコル。 このプロトコルを利用する代表的なプログラムがping</p></li><li><p> IGMP(Internet  Group  Message  Protocol):マルチキャスト用プロトコル</p></li></ul><h4 id="3-伝送階層-Transport-Layer"><a href="#3-伝送階層-Transport-Layer" class="headerlink" title="3. 伝送階層 (Transport Layer)"></a>3. 伝送階層 (Transport Layer)</h4><p>OSI7階層の伝送階層と同じです。 プロセス間の信頼性のあるデータ伝送を担う階層です。<br>process-to-process転送を担当するためには論理的アドレスが必要ですが、processが使用するポート番号をその論理的アドレスとして使います。<br>転送階層で動作するプロトコルは下記の通りです。</p><ul><li><p> TCP  (Transmission  Control  Protocol):信頼性のある接続指向型プロトコル。 信頼性があるというのは、そのペケットのエラー処理や再送信などでエラーを復旧することです。 そのためTCPのヘッダーに付く情報が多いです。</p></li><li><p> UDP  (User  Datagram  Protocol):非信頼性非接続型プロトコルです。 ペケットを失ったりエラーがあっても対処しないことです。 したがって、UDPヘッダーは簡単な構造を持っています。</p></li></ul><h4 id="4-応用階層-Application-Layer"><a href="#4-応用階層-Application-Layer" class="headerlink" title="4. 応用階層 (Application Layer)"></a>4. 応用階層 (Application Layer)</h4><p>ユーザーと最も近い階層です。 OSI7階層の5階層から7階層までの機能を担っています。<br>サーバやクライアントアプリケーションがこの階層で動作します。 私たちが知っているブラウザやテルネットのようなサービスがこの階層で動作し、動作するためには転送階層のアドレス、つまりポート番号を使用します。 例えば、httpが88番ポートを使用することと同じです。<br>応用階層で動作するプロトコルは以下の通りです。</p><ul><li><p> HTTP(Hyper-Text  Transfer  Protocol):TCPベースのプロトコルでポート番号80番を使用</p></li><li><p> Telnet  :TCP  ポート番号23番を使用します。 遠隔ターミナルを接続する際にこのプロトコルを使用</p></li><li><p>SSH(Secure  Shell):テルネットのようなサービスはセキュリティに脆弱。 パスワードが暗号化されていないため、そのまま表示されます。 これを補完したものがSSHです。 ポート番号22番を使用します。 SFTP  のようなプロトコルも22  番ポートで主要使用します。</p></li><li><p> FTP(File  Transfer  Protocol):  ファイル転送プロトコル。 ファイルのダウンロードやアップロードにFTPを使用。 FTPは、ファイルのアップロードやダウンロードの際、信頼性を重要視するため、TCPで動作します。 2  つのポートを使用します。</p></li></ul><p>TCPポート20番はデータ転送のための用途、TCPポート21番は制御用として使用します。</p><ul><li><p> SMTP  (Simple  Mail  Transfer  Protocol):メール転送プロトコルです。 TCP  上で動作し、ポートは  25  番を使用します。</p></li><li><p> POP3（Post  Office  Protocol  Version  3）:メール受信用プロトコルです。 アウトルックのようなプログラムはPOP3というプロトコルを使って動作します。 TCP  ポート110番を使用します。</p></li><li><p> DNS  (Domain  Name  System):ドメイン名に対するホスト情報を提供します。 基本的にUDP  上で動作します。 基本的に失敗したらもう一度要請すればいいですし、それほど重要な情報ではないからです。 しかし、信頼性を要する場合にはTCP上でも動作します。 データが長い場合、同じ時にTCPベースで動作できます。</p></li></ul><p>UDP、TCP  ポート53番を使用します。</p><p>このように、ポート番号が特定のプロトコルが使用していては使えないポートがあります。 このようなポートをwell-known  portといいます。</p><blockquote><footer><strong>参考 :</strong><cite><a href="https://reakwon.tistory.com/68">reakwon.tistory.com/68</a></cite></footer></blockquote>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/JAPANESE/">JAPANESE</category>
      
      <category domain="https://bny64.github.io/categories/JAPANESE/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/JAPANESE/STUDY/TECHNICAL-TERMS/">TECHNICAL TERMS</category>
      
      
      <category domain="https://bny64.github.io/tags/TCP/">TCP</category>
      
      <category domain="https://bny64.github.io/tags/IP/">IP</category>
      
      <category domain="https://bny64.github.io/tags/TCP-IP/">TCP?IP</category>
      
      <category domain="https://bny64.github.io/tags/TCP-%E6%A6%82%E5%BF%B5/">TCP 概念</category>
      
      <category domain="https://bny64.github.io/tags/TCP-%E6%84%8F%E5%91%B3/">TCP 意味</category>
      
      <category domain="https://bny64.github.io/tags/IP-%E6%A6%82%E5%BF%B5/">IP 概念</category>
      
      <category domain="https://bny64.github.io/tags/IP-%E6%84%8F%E5%91%B3/">IP 意味</category>
      
      
      <comments>https://bny64.github.io/2020/12/07/tcp-ip-jp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TCP/IP란?</title>
      <link>https://bny64.github.io/2020/12/01/tcp-ip/</link>
      <guid>https://bny64.github.io/2020/12/01/tcp-ip/</guid>
      <pubDate>Tue, 01 Dec 2020 07:57:06 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h4&gt;&lt;p&gt;인터넷 프로그램들이 서로 통신을 하는데 있어서 HTTP, SFTP, FTP 등 다양한 프로토콜이 </description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>인터넷 프로그램들이 서로 통신을 하는데 있어서 HTTP, SFTP, FTP 등 다양한 프로토콜이 있습니다. 인터넷 프로토콜에서 가장 많이 사용하는 대표적인 프로토콜은 여러분들도 많이 아시다시피 IP입니다. 여기서 중요한 것은 <code>TCP/IP</code>는 계층이 아니라 프로토콜이라는 점 입니다.<br><code>TCP/IP</code>는 OSI7 계층과는 조금은 다른 <code>TCP/IP</code>의 구조적인 계층 위에서 동작합니다<br><img src="tcp-ip_1.png" alt="tcp/ip"><br>OSI7 계층과는 조금은 다른 모습입니다.<br>계층의 갯수 부터가 다르고. OSI는 7계층인데 반해 TCP/IP 계층은 4계층이 전부라는 것을 알 수 있습니다.</p><h4 id="1-네트워크-인터페이스-계층-Network-Interface-Layer"><a href="#1-네트워크-인터페이스-계층-Network-Interface-Layer" class="headerlink" title="1. 네트워크 인터페이스 계층 (Network Interface Layer)"></a>1. 네트워크 인터페이스 계층 (Network Interface Layer)</h4><p>이 계층은 Node-To-Node간의 신뢰성 있는 데이터 전송을 담당하는 계층입니다.<br>OSI7 계층의 물리 계층과 데이터링크 계층의 역할을 이 네트워크 인터페이스 계층이 담당합니다.<br>따라서 MAC주소가 이 계층에서 사용됩니다.<br>네트워크 인터페이스 계층이 바로 데이터링크 계층까지 담당하니까 MAC 어드레스가 사용됩니다.<br><img src="lan-card.jpg" alt="랜카드"><br>위의 장비는 랜카드 입니다. 정확한 명칭은 NIC라고 하여 <code>Network Interface Card</code>입니다.<br>바로 이 랜카드가 있어야만 네트워크 통신을 할 수 있는데, 네트워크 인터페이스 계층에서 동작하는 장비입니다.</p><p>LAN상에서는 Ethernet, TokenRing, FDDI 등이 있으며 WAN 상에서는 X.25, Frame Relay, PPP 등이 있습니다.</p><h4 id="2-인터넷-계층-Internet-Layer"><a href="#2-인터넷-계층-Internet-Layer" class="headerlink" title="2. 인터넷 계층 (Internet Layer)"></a>2. 인터넷 계층 (Internet Layer)</h4><p>OSI7계층의 네트워크 계층을 담당하는 계층입니다. OSI7 계층처럼 호스트간의 라우팅을 담당하게 됩니다.<br>인터넷 계층에서 동작하는 프로토콜에는 아래와 같습니다.</p><ul><li><p>IP(Internet Protocol) : 비신뢰성, 비연결지향 데이터그램 프로토콜 </p></li><li><p>ARP(Address Resolution Protocol) : 주소변환 프로토콜입니다. IP주소를 MAC주소로 변환하는 프로토콜</p></li><li><p>RARP(Reverse ARP) : 반대로 MAC주소로 IP주소를 찾는 프로토콜</p></li><li><p>ICMP(Internet Control Message Protocol) : 상태 진단 메시지 프로토콜. 이 프로토콜을 이용하는 대표적인 프로그램이 ping</p></li><li><p>IGMP(Internet Group Message Protocol) : 멀티캐스트용 프로토콜</p></li></ul><h4 id="3-전송-계층-Transport-Layer"><a href="#3-전송-계층-Transport-Layer" class="headerlink" title="3. 전송 계층 (Transport Layer)"></a>3. 전송 계층 (Transport Layer)</h4><p>OSI7 계층의 전송계층과 같습니다. 프로세스간의 신뢰성 있는 데이터 전송을 담당하는 계층입니다.<br>process-to-process 전송을 담당하기 위해서는 논리적 주소가 필요한데 process가 사용하는 포트 번호를 그 논리적 주소로 사용합니다.<br>전송 계층에서 동작하는 프로토콜은 아래와 같습니다.</p><ul><li><p>TCP (Transmission Control Protocol) : 신뢰성있는 연결지향형 프로토콜. 신뢰성있다는 말은 그 페킷에 대한 오류처리나 재전송따위로 에러를 복구하는 것을 말합니다. 그때문에 TCP의 헤더에 붙는 정보가 많습니다.</p></li><li><p>UDP (User Datagram Protocol) : 비신뢰성 비연결형 프로토콜입니다. 페킷을 잃거나 오류가 있어도 대처하지 않는 것을 말합니다. 따라서 UDP헤더는 간단한 구조를 갖고 있습니다.</p></li></ul><h4 id="4-응용-계층-Application-Layer"><a href="#4-응용-계층-Application-Layer" class="headerlink" title="4. 응용 계층 (Application Layer)"></a>4. 응용 계층 (Application Layer)</h4><p>사용자와 가장 가까운 계층입니다. OSI7계층의 5계층부터 7계층까지의 기능을 담당하고 있습니다.<br>서버나 클라이언트 응용 프로그램이 이 계층에서 동작합니다. 우리가 알고 있는 브라우저나 텔넷같은 서비스가 이 계층에 동작하며, 동작하기 위해서는 전송계층의 주소, 즉 포트번호를 사용합니다. 예를들어 http가 88번 포트를 사용하는 것과 같습니다.<br>응용 계층에서 동작한느 프로토콜은 아래와 같습니다.</p><ul><li><p>HTTP (Hyper-Text Transfer Protocol) : TCP기반의 프로토콜로 포트번호 80번을 사용</p></li><li><p>Telnet : TCP 포트번호 23번을 사용합니다. 원격 터미널을 접속할때 이 포로토콜을 사용</p></li><li><p>SSH (Secure Shell) : 텔넷과 같은 서비스는 보안에 취약. 비밀번호가 암호화되지 않아 그대로 노출됩니다.. 이것을 보완한것이 SSH입니다. 포트번호 22번을 사용합니다. SFTP 같은 프로토콜도 22번 포트로 주요 사용합니다.</p></li><li><p>FTP(File Transfer Protocol) : 파일 전송 프로토콜. 파일을 받거나 올릴때 FTP를 사용. FTP는 파일을 올리거나 내려받을때 신뢰성을 중요시하기 때문에 TCP에서 동작합니다. 2개의 포트를 사용합니다.</p></li></ul><p>TCP 포트 20번은 데이터 전송을 위한 용도, TCP 포트 21번은 제어용으로 사용합니다.</p><ul><li><p>SMTP (Simple Mail Transfer Protocol) : 메일 전송 프로토콜입니다. TCP 상에서 동작하며 포트는 25번을 사용합니다.</p></li><li><p>POP3 (Post Office Protocol Version3) : 메일 수신용 프로토콜입니다. 아웃룩같은 프로그램이 POP3라는 프로토콜을 사용하여 동작합니다. TCP 포트 110번을 사용합니다.</p></li><li><p>DNS (Domain Name System) : 도메인명에 대한 호스트 정보를 제공해줍니다. 기본적으로 UDP상에서 동작합니다. 기본적으로 실패하면 다시 한번 요청하면 되며 그렇게 중요한 정보가 아니기 때문이죠. 하지만 신뢰성을 요할 경우에는 TCP상에서도 동작합니다. 데이터의 길이가 길 경우같은 때 TCP 기반으로 동작할 수 있습니다.</p></li></ul><p>UDP, TCP 포트 53번을 사용합니다.</p><p>이와 같이 포트번호가 특정 프로토콜이 사용해서 우리가 쓸 수 없는 포트들이 있습니다. 이런 포트들을 well-known port라고 합니다.</p><blockquote><footer><strong>참고 :</strong><cite><a href="https://reakwon.tistory.com/68">reakwon.tistory.com/68</a></cite></footer></blockquote>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/KOREAN/">KOREAN</category>
      
      <category domain="https://bny64.github.io/categories/KOREAN/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/KOREAN/STUDY/TECHNICAL-TERMS/">TECHNICAL TERMS</category>
      
      
      <category domain="https://bny64.github.io/tags/TCP/">TCP</category>
      
      <category domain="https://bny64.github.io/tags/IP/">IP</category>
      
      <category domain="https://bny64.github.io/tags/TCP-IP/">TCP?IP</category>
      
      <category domain="https://bny64.github.io/tags/TCP-%EA%B0%9C%EB%85%90/">TCP 개념</category>
      
      <category domain="https://bny64.github.io/tags/TCP-%EB%9C%BB/">TCP 뜻</category>
      
      <category domain="https://bny64.github.io/tags/IP-%EA%B0%9C%EB%85%90/">IP 개념</category>
      
      <category domain="https://bny64.github.io/tags/IP-%EB%9C%BB/">IP 뜻</category>
      
      
      <comments>https://bny64.github.io/2020/12/01/tcp-ip/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo search engine optimization</title>
      <link>https://bny64.github.io/2020/11/26/seo-en/</link>
      <guid>https://bny64.github.io/2020/11/26/seo-en/</guid>
      <pubDate>Thu, 26 Nov 2020 04:19:25 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;HEXO-search-engine-optimization-SEO&quot;&gt;&lt;a href=&quot;#HEXO-search-engine-optimization-SEO&quot; class=&quot;headerlink&quot; title=&quot;HEXO - search engine o</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="HEXO-search-engine-optimization-SEO"><a href="#HEXO-search-engine-optimization-SEO" class="headerlink" title="HEXO - search engine optimization(SEO)"></a>HEXO - search engine optimization(SEO)</h4><p><em>How can I make my blog search on various search sites?</em></p><p>After you create a blog, you need to proceed with optimization to expose your blog to the search engine.</p><h5 id="Installing-the-plug-in-required-for-search-engine-optimization-SEO"><a href="#Installing-the-plug-in-required-for-search-engine-optimization-SEO" class="headerlink" title="Installing the plug-in required for search engine optimization (SEO)"></a>Installing the plug-in required for search engine optimization (SEO)</h5><ul><li>hexo-auto-canonical</li><li>hexo-generator-robotstxt</li><li>hexo-autonofollow</li><li>hexo-generator-feed</li><li>hexo-generator-seo-friendly-sitemap</li></ul><h6 id="1-hexo-auto-canonical"><a href="#1-hexo-auto-canonical" class="headerlink" title="1. hexo-auto-canonical"></a>1. <code>hexo-auto-canonical</code></h6><p><strong>A plug-in that automatically makes a representative URL (standard link).</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-auto-canonical</span><br></pre></td></tr></table></figure><p>Install the module through <code>git</code> as shown above.<br>After installation, in the path of the blog (based on the main directory), Insert the code below <code>&lt;%- meta(page) %&gt;</code> in the ejs file that is <code>themes &gt; hueman &gt; layout &gt; common &gt; head.ejs</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.ejs</span><br><span class="line">&lt;%- autoCanonical(config, page) %&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;.jade</span><br><span class="line">| !&#123; autoCanonical(config, page) &#125;</span><br></pre></td></tr></table></figure><p>If inserted, the code will be as below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- meta(page) %&gt;</span><br><span class="line">&lt;%- autoCanonical(config, page) %&gt;</span><br></pre></td></tr></table></figure><h6 id="2-hexo-generator-robotstxt"><a href="#2-hexo-generator-robotstxt" class="headerlink" title="2. hexo-generator-robotstxt"></a>2. <code>hexo-generator-robotstxt</code></h6><p><strong>This plug-in automatically makes the robot.txt file.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-robotstxt --save</span><br></pre></td></tr></table></figure><p>Install the module through <code>git</code> as shown above.<br>After installation, open the <code>_config.yml (not the theme _config.yml)</code> file in the blog directory and input it as below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">robotstxt:</span><br><span class="line">useragent: &quot;*&quot;</span><br><span class="line">allow:</span><br><span class="line">- &#x2F;</span><br><span class="line">sitemap: https:&#x2F;&#x2F;username.github.io&#x2F;sitemap.xml</span><br></pre></td></tr></table></figure><h6 id="3-hexo-autonofollow"><a href="#3-hexo-autonofollow" class="headerlink" title="3. hexo-autonofollow"></a>3. <code>hexo-autonofollow</code></h6><p><strong>A plug-in that automatically adds <code>rel=&quot;external noofollow&quot;</code> properties to external links.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-autonofollow --save</span><br></pre></td></tr></table></figure><p>Install the module through <code>git</code> as shown above.<br>After installation, open the <code>_config.yml (not the theme _config.yml)</code> file in the blog directory and input it as below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nofollow:</span><br><span class="line">enable: true &#x2F;&#x2F;Plug-in enabled or disabled</span><br><span class="line">exclude: &#x2F;&#x2F;host to exclude</span><br><span class="line">- guest1.com</span><br><span class="line">- guest2.com</span><br></pre></td></tr></table></figure><h6 id="4-hexo-generator-feed"><a href="#4-hexo-generator-feed" class="headerlink" title="4. hexo-generator-feed"></a>4. <code>hexo-generator-feed</code></h6><p><strong>This plug-in automatically makes <code>RSS feed</code>.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>Install the module through <code>git</code> as shown above.<br>After installation, open the <code>_config.yml (not the theme _config.yml)</code> file in the blog directory and input it as below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">type: rss2 &#x2F;&#x2F;feed의 종류(atom&#x2F;rss2) * I recommend to write rss2</span><br><span class="line">path: rss2.xml &#x2F;&#x2F;Path where feed will be generated</span><br><span class="line">limit: 20 &#x2F;&#x2F;Set the latest number of posts (0 or false is the entire post)</span><br></pre></td></tr></table></figure><h6 id="5-hexo-generator-seo-friendly-sitemap"><a href="#5-hexo-generator-seo-friendly-sitemap" class="headerlink" title="5. hexo-generator-seo-friendly-sitemap"></a>5. <code>hexo-generator-seo-friendly-sitemap</code></h6><p><strong>Automatically creates site map xml files for crawlers to crawl blogs more efficiently.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-seo-friendly-sitemap --save</span><br></pre></td></tr></table></figure><p>Install the module through <code>git</code> as shown above.<br>After installation, open the <code>_config.yml (not the theme _config.yml)</code> file in the blog directory and input it as below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml &#x2F;&#x2F;Path where sitemap will be generated</span><br><span class="line">tag: false &#x2F;&#x2F;whether the tag is included in the sitemap</span><br><span class="line">category: false &#x2F;&#x2F;Whether to include a category in sitemap</span><br></pre></td></tr></table></figure><p>Adding all, _config.yml file will be completed as follows.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;example.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;username.github.io</span><br><span class="line">&#x2F;&#x2F;url : https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io</span><br><span class="line">&#x3D;&gt; If you enter this (reportory address, not blog address), be careful because rss2.xml does not read the file path properly!</span><br><span class="line">...</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io # Repository address where the GitHub page is stored</span><br><span class="line">    branch: main</span><br><span class="line">nofollow:</span><br><span class="line">    enable: true</span><br><span class="line">feed:</span><br><span class="line">    type: rss2</span><br><span class="line">    path: rss2.xml</span><br><span class="line">    limit: 20</span><br><span class="line">#sitemap auto generator</span><br><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br><span class="line">    tag: false</span><br><span class="line">    category: false</span><br><span class="line">robotstxt:</span><br><span class="line">    useragent: &quot;*&quot;</span><br><span class="line">    allow: </span><br><span class="line">    - &#x2F;</span><br><span class="line">sitemap: https:&#x2F;&#x2F;username.github.io&#x2F;sitemap.xml</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/ENGLISH/">ENGLISH</category>
      
      <category domain="https://bny64.github.io/categories/ENGLISH/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/ENGLISH/STUDY/BLOG/">BLOG</category>
      
      
      <category domain="https://bny64.github.io/tags/seo/">seo</category>
      
      <category domain="https://bny64.github.io/tags/SEO/">SEO</category>
      
      <category domain="https://bny64.github.io/tags/hexo/">hexo</category>
      
      <category domain="https://bny64.github.io/tags/search-engine-optimization/">search engine optimization</category>
      
      <category domain="https://bny64.github.io/tags/hexo-search-engine-optimization/">hexo search engine optimization</category>
      
      
      <comments>https://bny64.github.io/2020/11/26/seo-en/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>What is RTSP?</title>
      <link>https://bny64.github.io/2020/11/25/rtsp-en/</link>
      <guid>https://bny64.github.io/2020/11/25/rtsp-en/</guid>
      <pubDate>Tue, 24 Nov 2020 23:52:22 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;RTSP (real time streaming protocol)&lt;/code&gt; is a protocol for controlling real-time multimedia streams.&lt;br&gt;RealNetwork, Netscape, an</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>RTSP (real time streaming protocol)</code> is a protocol for controlling real-time multimedia streams.<br>RealNetwork, Netscape, and IBM co-developed.</p><h4 id="RTSP-Features"><a href="#RTSP-Features" class="headerlink" title="RTSP Features"></a>RTSP Features</h4><ul><li><p>Infrastructure for Multi-Point Streaming Applications<br>○ RTSP has the purpose of providing protocols for multimedia stream control in multi-branch applications that use both unicast or multicast connectivity in the application layer, but it can be seen as infrastructure rather than protocol.</p><br></li><li><p>Operates by client/server form<br>○ Structure, grammar, and operation are very similar to HTTP.</p><br></li><li><p>Session management<br>○ The setting and control of multiple multimedia sessions is controlled by RTSP.<br>○ Resource management setup and reservation of RTSP can be used with RSVP.</p><br></li><li><p>Several protocols are involved<br>○ The real-time transmission mechanism of real multimedia information is based on RTP/RTCP.</p><ul><li>RTP/RTCP Generates and controls time-synchronized streams in audio, video, etc.</li></ul><p>○ Works on a variety of transport protocols, including reliable TCP and unreliable UDP</p><ul><li>Mainly operating on UDP</li><li>RTSP (RTCP) real-time packets are delivered with the help of these protocols.<br>○ Use a different channel than RTP,RTCP (use 554 times as a different port number than the data transfer port)</li><li>RTP,RTCP is transmitted over the same channel.</li><li>RSTP performs full streaming control using channels different from RTP/RTCP.<br></li></ul></li></ul><h4 id="Control-commands-associated-with-streaming-playback"><a href="#Control-commands-associated-with-streaming-playback" class="headerlink" title="Control commands associated with streaming playback"></a>Control commands associated with streaming playback</h4><p>ㅇ Setup, Play, Forward, Rewind, Pause, Stop, Rescue, Record, TEARDOWN, etc.<br>     - This is a home VCR applied to the Internet.</p><p>ㅇ Examples of implementations by the Internet Web<br><img src="RTSP.jpg" alt="RTSP"></p><blockquote><footer><strong>차재복 (Cha Jae Bok)</strong><cite><a href="http://www.ktword.co.kr/abbr_view.php?m_temp1=1798">www.ktword.co.kr/abbr_view.php?m_temp1=1798</a></cite></footer></blockquote>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/ENGLISH/">ENGLISH</category>
      
      <category domain="https://bny64.github.io/categories/ENGLISH/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/ENGLISH/STUDY/NEW-TECHNOLOGY/">NEW TECHNOLOGY</category>
      
      
      <category domain="https://bny64.github.io/tags/RTSP-realtime-streaming-protocol/">RTSP, realtime streaming protocol</category>
      
      
      <comments>https://bny64.github.io/2020/11/25/rtsp-en/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>What is ONVIF?</title>
      <link>https://bny64.github.io/2020/11/24/ONVIF-en/</link>
      <guid>https://bny64.github.io/2020/11/24/ONVIF-en/</guid>
      <pubDate>Tue, 24 Nov 2020 04:13:33 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;ONVIF(The Open Network Video Interface Forum) is one of the World Open Industrial Forum (*), designed to facilitate the development and u</description>
        
      
      
      
      <content:encoded><![CDATA[<p>ONVIF(The Open Network Video Interface Forum) is one of the World Open Industrial Forum (*), designed to facilitate the development and use of world open standards for interfaces of physical IP-based products for security purposes. ONVIF sets standards for how IP products within video surveillance and other physical security zones can communicate with each other. ONVIF is an organization founded by Axis Communications, Bosch Security Systems and Sony in 2008.<br>To put it simply, it is an <code>international standard protocol</code> used to control cameras, and more specifically, it is a standard protocol used in security devices such as CCTVs, cameras, and viewers.</p><h4 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h4><p>Profile S<br>Common features of IP video systems such as video and audio streaming, PTZ options, and relay activation are mentioned.<br>Profile C<br>Explain the state of the door and the common functions of the IP access control system such as control, qualification management and event management management.<br>Profile G<br>Describe video storage, recording, and search.<br>Profile Q<br>Describes device discovery, configuration, and TLS authentication management.<br>Profile A<br>A function constitutes PACS (physical access control system) related items such as access rules, qualification information, and schedules by retrieving information, states, and events.<br>Profile T<br>(Candidate Release RC) Supports video streaming functions such as H.264, H.265 encoding format, imaging settings, and alarm events (motion, unjust change detection, etc..</p><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><p>It is a protocol that connects security equipment each other.<br><img src="ONVIF.png" alt="ONVIF"></p><p>Generally, security and video equipment support a variety of protocols, Normally the equipments use our own standard protocol and the <code>International Standard Protocol (ONVIF)</code>.<br>In the case of the<code> International Standard Protocol (ONVIF)</code>, since it does not support functions specific to the relevant device, it may use its own standard protocol.<br>When using ONVIF, new specifications and changes are difficult and time-consuming because they are a universal protocol. However, because it is a world standard, it can be used anywhere in the world.</p><p>Generally, there are socket-based protocols and HTTP-based protocols, but ONVIF uses the HTTP protocol.</p><table><thead><tr><th align="center">Features</th><th align="center">Protocol Type</th></tr></thead><tbody><tr><td align="center">Video, audio, and event sending</td><td align="center">RTP/RTSP protocol</td></tr><tr><td align="center">Control, Settings, Queries</td><td align="center">WSDL, SOAP Protocol</td></tr></tbody></table><p>We use view video using RTP/RTSP, and use WSDL, SOAP to modify IP or settings.<br>An ONVIF protocol does not embody the RTP/RTSP protocol, but serves to inform the RTP/RTSP address so that equipment such as a camera can be used.</p>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/ENGLISH/">ENGLISH</category>
      
      <category domain="https://bny64.github.io/categories/ENGLISH/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/ENGLISH/STUDY/NEW-TECHNOLOGY/">NEW TECHNOLOGY</category>
      
      
      <category domain="https://bny64.github.io/tags/ONVIF/">ONVIF</category>
      
      <category domain="https://bny64.github.io/tags/RTP/">RTP</category>
      
      <category domain="https://bny64.github.io/tags/RTSP/">RTSP</category>
      
      
      <comments>https://bny64.github.io/2020/11/24/ONVIF-en/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hexo 検索エンジン最適化</title>
      <link>https://bny64.github.io/2020/11/21/seo-jp/</link>
      <guid>https://bny64.github.io/2020/11/21/seo-jp/</guid>
      <pubDate>Sat, 21 Nov 2020 12:44:41 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;HEXO-検索エンジン最適化-SEO&quot;&gt;&lt;a href=&quot;#HEXO-検索エンジン最適化-SEO&quot; class=&quot;headerlink&quot; title=&quot;HEXO - 検索エンジン最適化(SEO)&quot;&gt;&lt;/a&gt;HEXO - 検索エンジン最適化(SEO)&lt;/h4&gt;&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="HEXO-検索エンジン最適化-SEO"><a href="#HEXO-検索エンジン最適化-SEO" class="headerlink" title="HEXO - 検索エンジン最適化(SEO)"></a>HEXO - 検索エンジン最適化(SEO)</h4><p><em>私のブログが色んな検索サイトから検索できるようにするためには？</em></p><p>ブログを作成した後、自分のブログが検索エンジンに露出されるようにするためには最適化作業を行わなければなりません。</p><h5 id="検索エンジン最適化-SEO-に必要なプラグインインストール"><a href="#検索エンジン最適化-SEO-に必要なプラグインインストール" class="headerlink" title="検索エンジン最適化(SEO)に必要なプラグインインストール"></a>検索エンジン最適化(SEO)に必要なプラグインインストール</h5><ul><li>hexo-auto-canonical</li><li>hexo-generator-robotstxt</li><li>hexo-autonofollow</li><li>hexo-generator-feed</li><li>hexo-generator-seo-friendly-sitemap</li></ul><h5 id="1-hexo-auto-canonical"><a href="#1-hexo-auto-canonical" class="headerlink" title="1. hexo-auto-canonical"></a>1. <code>hexo-auto-canonical</code></h5><p><strong>代表URL(標準リンク)を自動的に生成してくれるプラグインです。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-auto-canonical</span><br></pre></td></tr></table></figure><p>上記のようにgitでモジュールをインストールします。<br>インストール後、ブログの経路（メインディレクトリ基準）で<code>themes &gt; hueman &gt; layout &gt; common &gt; head.ejs</code>ファイル内に<code>&lt;%- meta(page) %</code>の下に以下のコードを入れます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.ejs</span><br><span class="line">&lt;%-autoCanonical(config, page)%&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;.jade</span><br><span class="line">| !&#123; autoCanonical(config, page)&#125;</span><br></pre></td></tr></table></figure><p>入れると以下のコードになります。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-meta(page) %&gt;</span><br><span class="line">&lt;%-autoCanonical(config, page)%&gt;</span><br></pre></td></tr></table></figure><h6 id="2-hexo-generator-robotstxt"><a href="#2-hexo-generator-robotstxt" class="headerlink" title="2. hexo-generator-robotstxt"></a>2. <code>hexo-generator-robotstxt</code></h6><p><strong>自動でrobot.txtファイルを生成してくれるプラグインです。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-robotstxt --save</span><br></pre></td></tr></table></figure><p>上記のように<code>git</code>でモジュールをインストールします。<br>インストール後のブログディレクトリの_<code>config.yml（テーマ_config.ymlではありません）</code>ファイルを開いて下記のように入力してください。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">robotstxt:</span><br><span class="line">    useragent:&quot;*&quot;</span><br><span class="line">    allow:</span><br><span class="line">    - &#x2F;</span><br><span class="line">    sitemap:https:&#x2F;&#x2F;username.github.io&#x2F;sitemap.xml</span><br></pre></td></tr></table></figure><h5 id="3-hexo-autonofollow"><a href="#3-hexo-autonofollow" class="headerlink" title="3. hexo-autonofollow"></a>3. <code>hexo-autonofollow</code></h5><p><strong>外部リンクに<code>rel=&quot;external nofollow&quot;</code>プロパティを自動的に追加してくれる機能をするプラグインです。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-autonofollow --save</span><br></pre></td></tr></table></figure><p>上記のように<code>git</code>でモジュールをインストールします。<br>インストール後のブログディレクトリの<code>_config.yml（テーマ_config.ymlではありません）</code>ファイルを開いて下記のように入力してください。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nofollow:</span><br><span class="line">    enable:true &#x2F;&#x2F;プラグイン活性化可否</span><br><span class="line">    exclude: &#x2F;&#x2F;除外させるhost</span><br><span class="line">    - guest1.com</span><br><span class="line">    - guest2.com</span><br></pre></td></tr></table></figure><h5 id="4-hexo-generator-feed"><a href="#4-hexo-generator-feed" class="headerlink" title="4. hexo-generator-feed"></a>4. <code>hexo-generator-feed</code></h5><p><strong>自動的に <code>RSS feed</code>を生成してくれるプラグインです。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed-save</span><br></pre></td></tr></table></figure><p>上記のように<code>git</code>でモジュールをインストールします。<br>インストール後のブログディレクトリの<code>_config.yml（テーマ_config.ymlではありません）</code>ファイルを開いて下記のように入力してください。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">    type:rss2 &#x2F;&#x2F;feedの種類(atom&#x2F;rss2) rss2おすすめします。</span><br><span class="line">    path:rss2.xml &#x2F;&#x2F;feedが生成される経路</span><br><span class="line">    limit:20 &#x2F;&#x2F;最新ポスト数設定（0またはfalseは全ポスト）</span><br></pre></td></tr></table></figure><h6 id="5-hexo-generator-seo-friendly-sitemap"><a href="#5-hexo-generator-seo-friendly-sitemap" class="headerlink" title="5. hexo-generator-seo-friendly-sitemap"></a>5. <code>hexo-generator-seo-friendly-sitemap</code></h6><p><strong>クローラがブログをより効率的にクロリングできるようにサイトマップxmlファイルを自動で生成してくれます。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-seo-friendly-sitemap --save</span><br></pre></td></tr></table></figure><p>上記のように<code>git</code>でモジュールをインストールします。<br>インストール後のブログディレクトリの_config.yml<code>（テーマ_config.ymlではありません）</code>ファイルを開いて下記のように入力してください。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">    path:sitemap.xml &#x2F;&#x2F; sitemapが生成される経路</span><br><span class="line">    tag:false &#x2F;&#x2F; sitemapにtagを含むかどうか</span><br><span class="line">    category:false &#x2F;&#x2F; sitemapにcategoryが含まれているかどうか</span><br></pre></td></tr></table></figure><p>すべて追加すると、<code>_config.yml</code>は以下のように作成されるようになります。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># URL</span><br><span class="line">##If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;example.com&#x2F;child&#39; and root as&#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url:https:&#x2F;&#x2F;username.github.io</span><br><span class="line">&#x2F;url:https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io</span><br><span class="line">このように入力するとrss2.xmlからファイル経路を正しく読み込めないので注意！</span><br><span class="line">...</span><br><span class="line"># Deployment</span><br><span class="line">＃＃Docs:https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">    type:git</span><br><span class="line">    repo:https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io # ギットハブページが保存されたリポジトリアドレス</span><br><span class="line">    branch:main</span><br><span class="line">nofollow:</span><br><span class="line">    enable:true</span><br><span class="line">feed:</span><br><span class="line">    type:rss2</span><br><span class="line">    path:rss2.xml</span><br><span class="line">    limit:20</span><br><span class="line">#sitemap auto generator</span><br><span class="line">    sitemap:</span><br><span class="line">    path:sitemap.xml</span><br><span class="line">    tag:false</span><br><span class="line">    category:false</span><br><span class="line">robotstxt:</span><br><span class="line">    useragent:&quot;*&quot;</span><br><span class="line">    allow:</span><br><span class="line">    - &#x2F;</span><br><span class="line">    sitemap:https:&#x2F;username.github.io&#x2F;sitemap.xml</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/JAPANESE/">JAPANESE</category>
      
      <category domain="https://bny64.github.io/categories/JAPANESE/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/JAPANESE/STUDY/BLOG/">BLOG</category>
      
      
      <category domain="https://bny64.github.io/tags/seo/">seo</category>
      
      <category domain="https://bny64.github.io/tags/SEO/">SEO</category>
      
      <category domain="https://bny64.github.io/tags/hexo/">hexo</category>
      
      <category domain="https://bny64.github.io/tags/%E6%A4%9C%E7%B4%A2%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%B3%E6%9C%80%E9%81%A9%E5%8C%96/">検索エンジン最適化</category>
      
      <category domain="https://bny64.github.io/tags/hexo%E6%A4%9C%E7%B4%A2%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%B3%E6%9C%80%E9%81%A9%E5%8C%96/">hexo検索エンジン最適化</category>
      
      
      <comments>https://bny64.github.io/2020/11/21/seo-jp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RTSPとは?</title>
      <link>https://bny64.github.io/2020/11/20/rtsp-jp/</link>
      <guid>https://bny64.github.io/2020/11/20/rtsp-jp/</guid>
      <pubDate>Fri, 20 Nov 2020 00:11:13 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;RTSP(real time streaming protocol)&lt;/code&gt; はリアルタイムマルチメディアストリームを制御するためのプロトコルである。&lt;br&gt;RealNetwork社、Netscape社、IBM社などが共同開発を行った。&lt;/p&gt;
&lt;h4 i</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>RTSP(real time streaming protocol)</code> はリアルタイムマルチメディアストリームを制御するためのプロトコルである。<br>RealNetwork社、Netscape社、IBM社などが共同開発を行った。</p><h4 id="RTSPの特徴"><a href="#RTSPの特徴" class="headerlink" title="RTSPの特徴"></a>RTSPの特徴</h4><ul><li><p>多地点ストリーミング応用のための基盤構造</p><ul><li>応用階層でユニキャストまたはマルチキャスト接続の両方を使用する多地点応用で、マルチメディアストリーム制御のためのプロトコル提供という目的を持つが、プロトコルというより基盤構造と見ることができる。<br></li></ul></li><li><p>クライアント/サーバーの形で動作</p><ul><li>構造、文法、動作方式がHTTPと非常に似ている。<br></li></ul></li><li><p>セッション管理</p><ul><li>多地点多数のマルチメディアセッションの設定と制御がRTSPによって制御される。</li><li>RTSPのリソース管理セットアップ及び予約はRSVPで使用可能<br></li></ul></li><li><p>複数のプロトコルが関連する</p><ul><li><p>実際のマルチメディア情報のリアルタイム転送メカニズムは、RTP/RTCPに基本基本としている。</p><ul><li>RTPRTCP:オーディオ、ビデオなどで時間同期化されたストリームを生成·制御する。</li></ul></li><li><p>信頼性のないTCP、非信頼的なUDPなど、様々な伝送プロトコルの上で動作可能。主にUDP上で動作</p><ul><li>このようなプロトコルの助けを受けてRTSP/RTP(RTCP)リアルタイムパケットが配信される。</li></ul></li><li><p>RTP、RTCPとは異なるチャンネルを使用（データ転送ポートとは異なるポート番号として554番を使用）</p><ul><li>RTP、RTCPは同一チャンネルを通じて転送されますが、</li><li>RSTPは、RTPRTCPとは異なるチャネルを使用して全体ストリーミング制御を行う。<br></li></ul></li></ul></li></ul><h4 id="ストリーミング再生に関する制御コマンド"><a href="#ストリーミング再生に関する制御コマンド" class="headerlink" title="ストリーミング再生に関する制御コマンド"></a>ストリーミング再生に関する制御コマンド</h4><p>ㅇ Setup(接続設定)、Play(再生)、Forward、Rewind、Pause(一時停止)、Stop(完全停止)、Resume(再起動)、Record、Teardown(接続解除)など、<br>    - 家庭用VCRをインターネットに適用したもの</p><p>インターネットウェブによる実装例<br><img src="rtsp.jpg" alt="RTSP"></p><blockquote><footer><strong>차재복 (Cha Jae Bok)</strong><cite><a href="http://www.ktword.co.kr/abbr_view.php?m_temp1=1798">www.ktword.co.kr/abbr_view.php?m_temp1=1798</a></cite></footer></blockquote>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/JAPANESE/">JAPANESE</category>
      
      <category domain="https://bny64.github.io/categories/JAPANESE/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/JAPANESE/STUDY/NEW-TECHNOLOGY/">NEW TECHNOLOGY</category>
      
      
      <category domain="https://bny64.github.io/tags/RTSP-realtime-streaming-protocol/">RTSP, realtime streaming protocol</category>
      
      
      <comments>https://bny64.github.io/2020/11/20/rtsp-jp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ONVIFとは？</title>
      <link>https://bny64.github.io/2020/11/19/ONVIF-jp/</link>
      <guid>https://bny64.github.io/2020/11/19/ONVIF-jp/</guid>
      <pubDate>Wed, 18 Nov 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;ONVIF（Open Network Video Interface Forum オープンネットワークビデオインターフェースフォーラム[*]、オンビーフ）は、世界開放型産業フォーラムの一つであり、セキュリティ目的の物理的なIP ベース製品のインターフェースのための世界開放型</description>
        
      
      
      
      <content:encoded><![CDATA[<p>ONVIF（Open Network Video Interface Forum オープンネットワークビデオインターフェースフォーラム[*]、オンビーフ）は、世界開放型産業フォーラムの一つであり、セキュリティ目的の物理的なIP ベース製品のインターフェースのための世界開放型標準の開発及び利用を容易にすることを目的とする。 ONVIF は動画監視その他の物理的な防犯地域内のIP 製品がどのように相互に通信できるかについての標準を作る。 ONVIFは2008年アクシスコミュニケーションズ、ボッシュセキュリティシステムズ、ソニーが立ち上げた団体である。<br>簡単に言えばカメラを制御する際に使われる<code>国際標準プロトコル</code>であり、詳しく言えばセキュリティ機器（CCTV、カメラ、ビューアーなど）で使われる標準プロトコルである。</p><h4 id="プロファイル"><a href="#プロファイル" class="headerlink" title="プロファイル"></a>プロファイル</h4><p>プロファイルS<br>ビデオやオーディオストリーミング、PTZオプション、リレーアクティベーションなどのIPビデオシステムの共通機能に言及する。<br>プロファイルC<br>ドアの状態及び制御、資格管理、イベント管理などのIPアクセス制御システムの共通機能を説明する。<br>プロファイルG<br>ビデオストレージ、録画、検索を説明する。<br>プロファイルQ<br>デバイス発見、構成、TLS 認証の管理について説明する。<br>プロファイルA<br>情報、状態、イベントの検索を行い、アクセス規則、資格情報、スケジュール等のPACS（物理アクセス制御システム）関連項目を構成する機能である。<br>プロファイルT<br>（発売候補RC）H.264、H.265エンコードフォーマット、イメージング設定、アラームイベント（モーション、不当変更検知など）などのビデオストリーミング機能をサポートする。</p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><p>セキュリティ装備同士を互いに接続して動作させるプロトコルである。<br><img src="ONVIF.png" alt="ONVIF"></p><p>一般的にセキュリティ装備、映像装備は様々なプロトコルをサポートしているが、自社標準プロトコルと<code>国際標準プロトコル(ONVIF)</code>を使用する。<br><code>国際標準プロトコル(ONVIF)</code>の場合、該当装置のみに特化している機能をサポートしないため、自社標準プロトコルを使用する場合もある。<br>ONVIF を使用する場合、全世界共通で使用するプロトコルであるため、新しい仕様や変更される作業は難しく時間がかかる。 しかし、世界標準であるため、世界のどこでも使うことができる。</p><p>一般的にプロトコルはsocket 通信基盤プロトコルとHTTP ベースプロトコルがあるが、ONVIF はHTTP プロトコルを使用する。</p><table><thead><tr><th align="center">機能</th><th align="center">プロトコルの種類</th></tr></thead><tbody><tr><td align="center">映像、音声、イベント送受信</td><td align="center">RTPRTSPプロトコル</td></tr><tr><td align="center">制御、設定、照会</td><td align="center">WSDL、SOAPプロトコル</td></tr></tbody></table><p>映像を見るときはRTPRTSPを使用し、IPを変更したり、設定を変更したりするときにはWSDL、SOAPを使用する<br>ONVIFプロトコルがRTPRTSPプロトコルを具現したのではなく、カメラのような装備を使用できるようにRTPRTSPアドレスを知らせる役割をする。</p>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/JAPANESE/">JAPANESE</category>
      
      <category domain="https://bny64.github.io/categories/JAPANESE/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/JAPANESE/STUDY/NEW-TECHNOLOGY/">NEW TECHNOLOGY</category>
      
      
      <category domain="https://bny64.github.io/tags/ONVIF/">ONVIF</category>
      
      <category domain="https://bny64.github.io/tags/RTP/">RTP</category>
      
      <category domain="https://bny64.github.io/tags/RTSP/">RTSP</category>
      
      
      <comments>https://bny64.github.io/2020/11/19/ONVIF-jp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hexo 검색엔진 최적화</title>
      <link>https://bny64.github.io/2020/11/18/seo/</link>
      <guid>https://bny64.github.io/2020/11/18/seo/</guid>
      <pubDate>Wed, 18 Nov 2020 06:49:53 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;HEXO-검색-엔진-최적화-SEO&quot;&gt;&lt;a href=&quot;#HEXO-검색-엔진-최적화-SEO&quot; class=&quot;headerlink&quot; title=&quot;HEXO - 검색 엔진 최적화(SEO)&quot;&gt;&lt;/a&gt;HEXO - 검색 엔진 최적화(SEO)&lt;/h4&gt;&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="HEXO-검색-엔진-최적화-SEO"><a href="#HEXO-검색-엔진-최적화-SEO" class="headerlink" title="HEXO - 검색 엔진 최적화(SEO)"></a>HEXO - 검색 엔진 최적화(SEO)</h4><p><em>내 블로그가 다양한 검색사이트에거 검색이 되게 하려면??</em></p><p>블로그를 생성한 후에 자신의 블로그가 검색엔진에 노출되게 하려면 최적화 작업을 진행해줘야 합니다.</p><h5 id="검색엔진-최적화-SEO-에-필요한-플러그인-설치"><a href="#검색엔진-최적화-SEO-에-필요한-플러그인-설치" class="headerlink" title="검색엔진 최적화(SEO)에 필요한 플러그인 설치"></a>검색엔진 최적화(SEO)에 필요한 플러그인 설치</h5><ul><li>hexo-auto-canonical</li><li>hexo-generator-robotstxt</li><li>hexo-autonofollow</li><li>hexo-generator-feed</li><li>hexo-generator-seo-friendly-sitemap</li></ul><h6 id="1-hexo-auto-canonical"><a href="#1-hexo-auto-canonical" class="headerlink" title="1. hexo-auto-canonical"></a>1. <code>hexo-auto-canonical</code></h6><p><strong>대표 URL(표준 링크)을 자동으로 생성해주는 플러그인입니다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-auto-canonical</span><br></pre></td></tr></table></figure><p>위와 같이 <code>git</code>을 통하여 모듈을 설치합니다.<br>설치 후 블로그의 경로(메인 디렉토리 기준)에서 <code>themes &gt; hueman &gt; layout &gt; common &gt; head.ejs</code> 파일 내에 <code>&lt;%- meta(page) %&gt;</code> 아래에 아래의 코드를 넣어줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.ejs</span><br><span class="line">&lt;%- autoCanonical(config, page) %&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;.jade</span><br><span class="line">| !&#123; autoCanonical(config, page) &#125;</span><br></pre></td></tr></table></figure><p>삽입하게 되면 아래와 같은 코드가 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- meta(page) %&gt;</span><br><span class="line">&lt;%- autoCanonical(config, page) %&gt;</span><br></pre></td></tr></table></figure><h6 id="2-hexo-generator-robotstxt"><a href="#2-hexo-generator-robotstxt" class="headerlink" title="2. hexo-generator-robotstxt"></a>2. <code>hexo-generator-robotstxt</code></h6><p><strong>자동으로 robot.txt 파일을 생성해주는 플러그인 입니다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-robotstxt --save</span><br></pre></td></tr></table></figure><p>위와 같이 <code>git</code>을 통하여 모듈을 설치합니다.<br>설치 후 블로그 디렉토리의 <code>_config.yml(테마 _config.yml 아닙니다.)</code> 파일을 열어 아래와 같이 입력해줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">robotstxt:</span><br><span class="line">  useragent: &quot;*&quot;</span><br><span class="line">  allow:</span><br><span class="line">    - &#x2F;</span><br><span class="line">  sitemap: https:&#x2F;&#x2F;username.github.io&#x2F;sitemap.xml</span><br></pre></td></tr></table></figure><h6 id="3-hexo-autonofollow"><a href="#3-hexo-autonofollow" class="headerlink" title="3. hexo-autonofollow"></a>3. <code>hexo-autonofollow</code></h6><p><strong>외부 링크에 <code>rel=&quot;external nofollow&quot;</code>속성을 자동으로 추가해주는 기능을 하는 플러그인입니다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-autonofollow --save</span><br></pre></td></tr></table></figure><p>위와 같이 <code>git</code>을 통하여 모듈을 설치합니다.<br>설치 후 블로그 디렉토리의 <code>_config.yml(테마 _config.yml 아닙니다.)</code> 파일을 열어 아래와 같이 입력해줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nofollow:</span><br><span class="line">    enable: true &#x2F;&#x2F;플러그인 활성화 여부</span><br><span class="line">    exclude: &#x2F;&#x2F;제외시킬 host</span><br><span class="line">    - guest1.com</span><br><span class="line">    - guest2.com</span><br></pre></td></tr></table></figure><h6 id="4-hexo-generator-feed"><a href="#4-hexo-generator-feed" class="headerlink" title="4. hexo-generator-feed"></a>4. <code>hexo-generator-feed</code></h6><p><strong>자동으로 <code>RSS feed</code>를 생성해주는 플러그인 입니다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>위와 같이 <code>git</code>을 통하여 모듈을 설치합니다.<br>설치 후 블로그 디렉토리의 <code>_config.yml(테마 _config.yml 아닙니다.)</code> 파일을 열어 아래와 같이 입력해줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">  type: rss2 &#x2F;&#x2F;feed의 종류(atom&#x2F;rss2) *네이버는 atom를 지원하지 않기 때문에 rss2 추천</span><br><span class="line">  path: rss2.xml &#x2F;&#x2F;feed가 생성될 경로</span><br><span class="line">  limit: 20 &#x2F;&#x2F;최신 포스트 갯수 설정(0 또는 false는 전체 포스트)</span><br></pre></td></tr></table></figure><h6 id="5-hexo-generator-seo-friendly-sitemap"><a href="#5-hexo-generator-seo-friendly-sitemap" class="headerlink" title="5. hexo-generator-seo-friendly-sitemap"></a>5. <code>hexo-generator-seo-friendly-sitemap</code></h6><p><strong>크롤러가 블로그를 더욱 효율적으로 크롤링 할 수 있도록 사이트맵 xml 파일을 자동으로 생성해 줍니다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-seo-friendly-sitemap --save</span><br></pre></td></tr></table></figure><p>위와 같이 <code>git</code>을 통하여 모듈을 설치합니다.<br>설치 후 블로그 디렉토리의 <code>_config.yml(테마 _config.yml 아닙니다.)</code> 파일을 열어 아래와 같이 입력해줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml &#x2F;&#x2F;sitemap이 생성될 경로</span><br><span class="line">  tag: false &#x2F;&#x2F;sitemap에 tag 포함 여부</span><br><span class="line">  category: false &#x2F;&#x2F;sitemap에 category 포함 여부</span><br></pre></td></tr></table></figure><p>모두 추가하게 되면 _config.yml는 아래와 같이 작성되게 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;example.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;username.github.io</span><br><span class="line">&#x2F;&#x2F;url : https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io </span><br><span class="line">&#x3D;&gt; 이렇게(블로그 주소가 아니라 repository 주소) 입력하게 되면 rss2.xml에서 파일 경로를 제대로 읽어오지 못하기 때문에 주의!</span><br><span class="line">...</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io # 깃허브 페이지가 저장된 리포지토리 주소</span><br><span class="line">  branch: main</span><br><span class="line">nofollow:</span><br><span class="line">  enable: true</span><br><span class="line">feed:</span><br><span class="line">  type: rss2</span><br><span class="line">  path: rss2.xml</span><br><span class="line">  limit: 20</span><br><span class="line">#sitemap auto generator</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">  tag: false</span><br><span class="line">  category: false</span><br><span class="line">robotstxt:</span><br><span class="line">  useragent: &quot;*&quot;</span><br><span class="line">  allow:</span><br><span class="line">    - &#x2F;</span><br><span class="line">  sitemap: https:&#x2F;&#x2F;username.github.io&#x2F;sitemap.xml</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/KOREAN/">KOREAN</category>
      
      <category domain="https://bny64.github.io/categories/KOREAN/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/KOREAN/STUDY/BLOG/">BLOG</category>
      
      
      <category domain="https://bny64.github.io/tags/seo/">seo</category>
      
      <category domain="https://bny64.github.io/tags/SEO/">SEO</category>
      
      <category domain="https://bny64.github.io/tags/hexo/">hexo</category>
      
      <category domain="https://bny64.github.io/tags/%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%B5%9C%EC%A0%81%ED%99%94/">검색엔진최적화</category>
      
      <category domain="https://bny64.github.io/tags/hexo-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84-%EC%B5%9C%EC%A0%81%ED%99%94/">hexo 검색엔진 최적화</category>
      
      
      <comments>https://bny64.github.io/2020/11/18/seo/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RTSP란?</title>
      <link>https://bny64.github.io/2020/11/17/rtsp/</link>
      <guid>https://bny64.github.io/2020/11/17/rtsp/</guid>
      <pubDate>Tue, 17 Nov 2020 07:28:29 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;RTSP(real time streaming protocol)&lt;/code&gt; 는 실시간 멀티미디어 스트림을 제어하기 위한 프로토콜이다.&lt;br&gt;RealNetwork사, Netscape사, IBM사 등이 공동개발을 하였다.&lt;/p&gt;
&lt;h4 i</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>RTSP(real time streaming protocol)</code> 는 실시간 멀티미디어 스트림을 제어하기 위한 프로토콜이다.<br>RealNetwork사, Netscape사, IBM사 등이 공동개발을 하였다.</p><h4 id="RTSP의-특징"><a href="#RTSP의-특징" class="headerlink" title="RTSP의 특징"></a>RTSP의 특징</h4><ul><li><p>다지점 스트리밍 응용을 위한 기반구조</p><ul><li>응용계층에서 유니캐스트 또는 멀티캐스트 연결 모두를 사용하는 다지점 응용에서, 멀티미디어 스트림 제어를 위한 프로토콜 제공이라는 목적을 가지나, 프로토콜이라기 보다는 기반구조라고 볼 수 있음<br></li></ul></li><li><p>클라이언트/서버 형태로 동작</p><ul><li>구조,문법,동작방식이 HTTP 와 매우 유사<br></li></ul></li><li><p>세션 관리</p><ul><li>다지점 다수개의 멀티미디어 세션의 설정과 제어가 RTSP에 의하여 제어됨</li><li>RTSP의 자원 관리 셋업 및 예약은 RSVP를 가지고 사용 가능<br></li></ul></li><li><p>여러 프로토콜들이 관련됨</p><ul><li><p>실제 멀티미디어 정보의 실시간 전송 매커니즘은 RTP/RTCP에 기본을 두고 있음</p><ul><li>RTP/RTCP : 오디오,비디오 등에서 시간 동기화된 스트림을 생성 및 제어함</li></ul></li><li><p>신뢰적인 TCP, 비신뢰적인 UDP 등 다양한 전송 프로토콜 위에서 동작 가능<br>  주로 UDP 위에서 동작</p><ul><li>이러한 프로토콜의 도움을 받아 RTSP/RTP(RTCP) 실시간 패킷이 전달됨</li></ul></li><li><p>RTP,RTCP와는 다른 채널 사용 (데이터 전송 포트와 다른 포트번호로써 554번 사용)</p><ul><li>RTP,RTCP는 동일 채널을 통해 전송된다.</li><li>RSTP는 RTP/RTCP와 다른 채널을 사용하여 전체 스트리밍 제어를 수행함<br></li></ul></li></ul></li></ul><h4 id="스트리밍-재생과-관련된-제어-명령어"><a href="#스트리밍-재생과-관련된-제어-명령어" class="headerlink" title="스트리밍 재생과 관련된 제어 명령어"></a>스트리밍 재생과 관련된 제어 명령어</h4><p>ㅇ Setup(연결설정), Play(재생), Forward, Rewind, Pause(일시멈춤), Stop(완전정지), Resume(다시시작), Record, Teardown(연결해제) 등<br>     - 가정용 VCR을 인터넷에 적용한 것임</p><p>ㅇ 인터넷 웹에 의한 구현 例<br><img src="RTSP.jpg" alt="RTSP"></p><blockquote><footer><strong>차재복 (Cha Jae Bok)</strong><cite><a href="http://www.ktword.co.kr/abbr_view.php?m_temp1=1798">www.ktword.co.kr/abbr_view.php?m_temp1=1798</a></cite></footer></blockquote>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/KOREAN/">KOREAN</category>
      
      <category domain="https://bny64.github.io/categories/KOREAN/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/KOREAN/STUDY/NEW-TECHNOLOGY/">NEW TECHNOLOGY</category>
      
      
      <category domain="https://bny64.github.io/tags/RTSP-realtime-streaming-protocol/">RTSP, realtime streaming protocol</category>
      
      
      <comments>https://bny64.github.io/2020/11/17/rtsp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ONVIF란?</title>
      <link>https://bny64.github.io/2020/11/15/ONVIF/</link>
      <guid>https://bny64.github.io/2020/11/15/ONVIF/</guid>
      <pubDate>Sun, 15 Nov 2020 06:44:51 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;ONVIF(Open Network Video Interface Forum 오픈 네트워크 비디오 인터페이스 포럼[*], 온비프)는 세계 개방형 산업 포럼의 하나로서, 보안 목적의 물리적인 IP 기반 제품들의 인터페이스를 위한 세계 개방형 표준의 개</description>
        
      
      
      
      <content:encoded><![CDATA[<p>ONVIF(Open Network Video Interface Forum 오픈 네트워크 비디오 인터페이스 포럼[*], 온비프)는 세계 개방형 산업 포럼의 하나로서, 보안 목적의 물리적인 IP 기반 제품들의 인터페이스를 위한 세계 개방형 표준의 개발 및 이용을 용이하게 하는 것을 목적으로 한다. ONVIF는 동영상 감시 및 기타 물리적인 방범 지역 내의 IP 제품들이 어떻게 서로 통신할 수 있는지에 대한 표준을 만든다. ONVIF는 2008년 액시스 커뮤니케이션스, 보쉬 시큐리티 시스템스, 소니가 시작한 단체이다.<br>간단히 말해 카메라를 제어할 때 사용되는 <code>국제 표준 프로토콜</code>이고 자세히 말하면 보안장비(CCTV, 카메라, 뷰어 등)에서 사용되는 표준 프로토콜이다.</p><h4 id="프로파일"><a href="#프로파일" class="headerlink" title="프로파일"></a>프로파일</h4><p>프로파일 S<br>비디오 및 오디오 스트리밍, PTZ 옵션, 릴레이 액티베이션 등의 IP 비디오 시스템의 공통 기능을 언급한다.<br>프로파일 C<br>도어 상태 및 제어, 자격 관리, 이벤트 관리 등의 IP 접근 통제 시스템의 공통 기능을 설명한다.<br>프로파일 G<br>비디오 스토리지, 녹화, 검색을 설명한다.<br>프로파일 Q<br>장치 발견, 구성, TLS 인증의 관리에 대해 설명한다.<br>프로파일 A<br>정보, 상태, 이벤트의 검색을 수행하고, 접근 규칙, 자격 정보, 스케줄 등의 PACS(물리 접근 제어 시스템) 관련 항목들을 구성하는 기능이다.<br>프로파일 T<br>(출시 후보/RC) H.264, H.265 인코딩 포맷, 이미징 설정, 알람 이벤트(모션, 부당 변경 감지 등) 등의 비디오 스트리밍 기능을 지원한다.</p><h4 id="용도"><a href="#용도" class="headerlink" title="용도"></a>용도</h4><p>보안장비끼리 서로 연결되어 동작하게 해주는 프로토콜이다.<br><img src="ONVIF.png" alt="ONVIF"></p><p>일반적으로 보안장비, 영상장비들은 다양한 프로토콜을 지원하고 있는데 자사 표준 프로토콜과 <code>국제 표준 프로토콜(ONVIF)</code>을 사용한다.<br><code>국제 표준 프로토콜(ONVIF)</code>의 경우 해당 장비에만 특화되어 있는 기능을 지원하지 않기 때문에 자사 표준 프로토콜을 사용하는 경우도 있다.<br>ONVIF를 사용할 경우 전세계 공통적으로 사용하는 프로토콜이기 때문에 새로운 사양이나 변경되는 작업이 어렵고 오래 걸린다. 하지만 세계 표준이기 때문에 세계 어디서든 사용할 수 있다.</p><p>일반적으로 프로토콜은 socket 통신 기반 프로토콜과 HTTP기반 프로토콜이 있는데 ONVIF는 HTTP 프로토콜을 사용한다.</p><table><thead><tr><th align="center">기능</th><th align="center">프로토콜의 종류</th></tr></thead><tbody><tr><td align="center">영상, 음성, 이벤트 송수신</td><td align="center">RTP/RTSP 프로토콜</td></tr><tr><td align="center">제어, 설정, 조회</td><td align="center">WSDL, SOAP 프로토콜</td></tr></tbody></table><p>영상을 볼 때는 RTP/RTSP를 사용하고, IP를 변경하거나 설정을 변경하거나 할 때에는 WSDL, SOAP를 사용한다<br>ONVIF 프로토콜이 RTP/RTSP 프로토콜을 구현한게 아니라 카메라와 같은 장비를 사용할 수 있도록 RTP/RTSP 주소를 알려주는 역할을 한다.</p>]]></content:encoded>
      
      
      <category domain="https://bny64.github.io/categories/KOREAN/">KOREAN</category>
      
      <category domain="https://bny64.github.io/categories/KOREAN/STUDY/">STUDY</category>
      
      <category domain="https://bny64.github.io/categories/KOREAN/STUDY/NEW-TECHNOLOGY/">NEW TECHNOLOGY</category>
      
      
      <category domain="https://bny64.github.io/tags/ONVIF/">ONVIF</category>
      
      <category domain="https://bny64.github.io/tags/RTP/">RTP</category>
      
      <category domain="https://bny64.github.io/tags/RTSP/">RTSP</category>
      
      <category domain="https://bny64.github.io/tags/ONVIF-%EA%B0%9C%EB%85%90/">ONVIF 개념</category>
      
      <category domain="https://bny64.github.io/tags/ONVIF-%EB%9C%BB/">ONVIF 뜻</category>
      
      
      <comments>https://bny64.github.io/2020/11/15/ONVIF/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
